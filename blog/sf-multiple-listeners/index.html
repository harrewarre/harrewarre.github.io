<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>harre.dev | Multiple listeners for your Service Fabric service</title>
    <link rel="stylesheet" href="/assets/style/theme.css">
  </head>
  <body>
    <header>
        <div class="content-wrapper">
            <h1><a href="/">harre.dev</a></h1>
        </div>
    </header>
    <nav>
        <div class="content-wrapper">
          <a href="/">home</a>
          <a href="/blog">blog</a>
          <a href="/about">about</a>
          <a href="/feed.xml">rss</a>
        </div>
    </nav>
    <main>
      <div class="content-wrapper">
        <h1>Multiple listeners for your Service Fabric service</h1>
<p>Service Fabric is a great piece of technology on the Azure platform and I've been using it quite a lot in recent projects. It takes away a lot of the setup and orchestration when dealing with microservices.</p>
<p>There comes a point where services need to talk to each other and this is easily achieved using the Remoting bits you can get from NuGet. The general way of doing this is creating an <code>Interfaces</code> project next to the service that
contains the service interface and classes used in transport. The interface is implemented on the service entrypoint and a listener is exposed to the Fabric runtime so that it can communicate with the rest of the platform. We're
going to take it one step further and put the service implementations in their own class instead of on the service entrypoint (keeps things nice and clean) and also enable dependency injection from that point forward.</p>
<p>This new way lets us define as many service endpoints as we want without cluttering the service entrypoint, each with their own listener. Let's dive in!</p>
<p>Before we can start creating endpoints, we need to set up an interface that forces any new service to expose a listener.</p>
<p>public interface IServiceEndpoint
{
ServiceInstanceListener Init<T>(T service) where T : StatelessService;
}</p>
<p>We're working inside a <code>Stateless</code> service so that's what we'll enforce on the generic part of the interface. Implementors of this interface now must be able to give us back a listener that exposes the methods it will offer.</p>
<p>Inside the <code>.Interfaces</code> project for the service contracts, we setup the actual service interface:</p>
<p>public interface IAgeService : IService
{
Task<int> GetAverageAge();
}</p>
<p>This interface defines the methods we want to expose.</p>
<p>Now that we have this all set up, we can go ahead and create the service implementation inside the stateless service:</p>
<p>public class AgeService : IServiceEndpoint, IAgeService
{
private readonly Random _randomAgeMaker;</p>
<p>public AgeService()
{
...
}</p>
<p>public Task<int> GetAverageAge()
{
...
}</p>
<p>public ServiceInstanceListener Init<T>(T service) where T : StatelessService
{
return new ServiceInstanceListener(context =&gt;
{
return new FabricTransportServiceRemotingListener(context, this, new FabricTransportRemotingListenerSettings
{
EndpointResourceName = $&quot;{nameof(AgeService)}&quot;
});
}, $&quot;{nameof(AgeService)}&quot;);
}
}</p>
<p>We apply two things here. First we implement the endpoint interface that forces us to make a listener for this service, the second is the interface that defines the services methods. Listeners require a unique name, so when
we create the new <code>FabricTransportServiceRemotingListener</code> we give it a <code>FabricTransportRemotingListenerSettings</code> instance containing a name we can easily recognize in the form of the service name.</p>
<p>This service is now ready to be made accessible to other services in our Fabric Application but we have a few more things to take care of. To keep it all nice and clean we want to use dependency injection for the composition of our services. In this
demo I'm using SimpleInjector but any other framework should also work.</p>
<p>The dependencies need to be registered in the root of the application, which in our case is <code>Program.cs</code>. At the very top of the <code>Main(...)</code> method, a container is created that will manage our dependecy graph for us:</p>
<p>var assemblies = AppDomain.CurrentDomain.GetAssemblies();
var container = new Container();</p>
<p>container.RegisterCollection(typeof(IServiceEndpoint), assemblies);
container.Register(typeof(IDiagnosticsTracer), typeof(DiagnosticsTracer));</p>
<p>container.Verify();</p>
<p>I've included a very basic logging facility to demonstrate the injection in practice, you can replace it with any dependencies you might have for your services.</p>
<p>The container is passed into the service itself through its constructor, where we'll ask for all the <code>IServiceEndpoints</code> it knows about. When the platform starts asking for listeners we point it to our list of services and call their <code>Init(...)</code> methods to grab the listeners.</p>
<p>internal sealed class People : StatelessService
{
private readonly IEnumerable<IServiceEndpoint> _services;</p>
<p>public People(StatelessServiceContext context, Container container)
: base(context)
{
_services = container.GetAllInstances<IServiceEndpoint>();
}</p>
<p>protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
{
return _services.Select(s =&gt; s.Init(this));
}
}</p>
<p>Now that the container is in charge of dependecies at the very root of our application, we can start injecting things into services like we would in any constructor injection scenario.
You can check out the other service in the demo project for a little preview where I use the <code>IDiagnosticsTracer</code> inside the NameService to report any activity.</p>
<p><img src="sf-listeners.png" alt="Listeners"></p>
<p>The service is now complete but we don't have a way to access it yet from the Api project. We can remote into the service using a <code>Proxy</code> that is created based on the service interface in the <code>Interfaces</code> project.
It's almost the same as setting up a normal project with one notable exception, we have to pass in the name of the listener we want to talk to:</p>
<p>_namesProxy = ServiceProxy.Create<INameService>(new Uri(&quot;fabric:/SF.Listeners/SF.Listeners.People&quot;), listenerName: &quot;NameService&quot;);
_ageProxy = ServiceProxy.Create<IAgeService>(new Uri(&quot;fabric:/SF.Listeners/SF.Listeners.People&quot;), listenerName: &quot;AgeService&quot;);</p>
<p>The proxy is then used like every other proxy you've ever created for remoting on Service Fabric:</p>
<p>[HttpGet]
[Route(&quot;all&quot;)]
public async Task<IActionResult> AllNames()
{
try
{
return Ok(await _namesProxy.GetAllNames());
}
catch (Exception ex)
{
throw;
}
}</p>
<p>Running a <code>GET</code> request against the HTTP endpoint above will remote into our <code>NameService</code> in the Stateless <code>People</code> service and retrieve all the names.</p>
<p>The demo code be executed on your local cluster and is accessible through and HTTP API in the <code>.Api</code> project using something like Postman or curl (or any other HTTP client).</p>
<p>You can find <a href="https://github.com/harrewarre/sf-listeners">the source for this demo on Github</a>.</p>

      </div>
    </main>
    <footer>
      <div class="content-wrapper">
        <p>Â© 2025 harre.dev</p>
       </div>
    </footer>
  </body>
</html>
