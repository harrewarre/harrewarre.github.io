<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>harre.dev | Multiple DbContext&#39;s with migrations on a single database</title>
    <link rel="stylesheet" href="/assets/style/theme.css">
    <link rel="stylesheet" href="/assets/style/prism-okaidia.css">
    <link rel="icon" type="image/png" href="/assets/favicon.png">
  </head>
  <body>
    <main>
    <header>
      <h1>
        <a href="/">harre.dev</a>
      </h1>
    </header>
    <nav>
      <a href="/">home</a>
      <a href="/blog">blog</a>
      <a href="/about">about</a>
      <a href="https://hachyderm.io/@harre" rel="me">me</a>
      <a href="/feed.xml">rss</a>
    </nav>
      
<article>
    <div class="post-date">2016-03-02 </div>
    <h1>Multiple DbContext's with migrations on a single database</h1>
<p>Here is a small problem I ran into while working on my current project. This project already has an Entity Framework <a href="https://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext(v=vs.113).aspx"><code>DbContext</code></a> class with entities and a database. I'm adding a new feature but want to keep the changes as isolated as possible. So I wanted to create a second <code>DbContext</code> that handles the entities specific to my new feature.</p>
<p>Adding the context to the codebase is no hassle, just create the new class and derive it from <code>DbContext</code>. The problem is in the <a href="https://msdn.microsoft.com/en-us/data/jj591621.aspx">migrations</a>. Entity Framework has a system that can track changes to the model and apply those changes to the actual database. To keep track of these changes, Entity Framework uses a table called <code>__MigrationHistory</code> where it stores all kinds of metadata about the model that it can compare to when you make changes to your entities in code.</p>
<p><img src="dbo_MigHist.png" alt="__MigrationHistory table"></p>
<p>If a second <code>DbContext</code> is added, and I enable migrations on it, it will create a second <code>__MigrationHistory</code> table. That's not going to work because that table already exists and contains migration data from the <strong>other</strong>  <code>DbContext</code>!</p>
<p>To get around this we use a feature of the database itself: Schema's. If we tell the new <code>DbContext</code> to work on a different <code>schema</code> than the rest of the database, it'll be like it's working on its own database while still getting easy access to existing tables. So how do we get the <code>DbContext</code> to work on a different schema? Turns out that's really easy:</p>
<p>public class TheNewContext : DbContext
{
<snip></p>
<p>protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
modelBuilder.HasDefaultSchema(&quot;TheNewSchema&quot;);
}
}</p>
<p>Open the class that represents the new <code>DbContext</code> and override the <code>OnModelCreating</code> method. This gives you access to the modelbuilder where you can set a default schema for this specific context. If you now <a href="https://msdn.microsoft.com/en-us/data/jj591621.aspx#enabling">enable migrations</a> on the context and <a href="https://msdn.microsoft.com/en-us/data/jj591621.aspx#generating">create the database</a> from the new model it will live in its own set of tables grouped by the default schema you gave it.</p>
<p>And that's all there is to it. You now have a single database that is accessed by two different <code>DbContext</code>'s each with their own migration history.</p>

    <div class="tags">
        
            c#
        
            entity framework
        
            databases
        
            itq
        
    </div>
</article>

    <footer>
      <p>Â© 2025 harre.dev</p>
    </footer>
    </main>
  </body>
</html>
