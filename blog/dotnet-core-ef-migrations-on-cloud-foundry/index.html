<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>harre.dev | Dotnet Core Entity Framework Migrations on Cloud Foundry</title>
    <link rel="stylesheet" href="/assets/style/theme.css">
  </head>
  <body>
    <header>
        <div class="content-wrapper">
            <h1><a href="/">harre.dev</a></h1>
        </div>
    </header>
    <nav>
        <div class="content-wrapper">
          <a href="/">home</a>
          <a href="/blog">blog</a>
          <a href="/about">about</a>
          <a href="/feed.xml">rss</a>
        </div>
    </nav>
    <main>
      <div class="content-wrapper">
        <h1>Dotnet Core Entity Framework Migrations on Cloud Foundry</h1>
<p>Run database migrations on Cloud Foundry using a task to ensure that migrations are only done once on deployment (and not during app start up!) for dotnet core applications. This post assumes you are deploying built applications and not raw source code.</p>
<p>Instead of depending on dotnet tooling (<code>dotnet-ef</code>), leverage the built-in migration capability of the DataContext. Interrupt the startup procedure when a special argument is passed in, instead of starting the web application, run the migrations and then exit.
So here we go, to start we need a DbContext:</p>
<pre><code class="language-csharp">using Microsoft.EntityFrameworkCore;  
  
namespace MyApp.Secondary;  
  
public class MyDbContext : DbContext  
{  
    public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options)  
        : base(options)  
    { }
    
    public DbSet&lt;User&gt; Users { get; set; }
}
</code></pre>
<p>In the solution that I was working on we had a factory that can create a DbContext when one is needed.</p>
<pre><code class="language-csharp">using Microsoft.EntityFrameworkCore;  
  
namespace MyApp.Secondary;  
  
public interface IMyDbContextFactory
{  
    MyDbContextFactory Create();  
}  
  
public class MyDbContextFactory(IConfiguration configuration) : IMyDbContextFactory  
{  
    public MyDbContextFactory Create()  
    {
	    var services = new VcapServices(configuration);  
        var connectionString = services.GetPostGresConnectionString(&quot;my-database-service&quot;);  
        var optionsBuilder = new DbContextOptionsBuilder&lt;MyDbContext&gt;();  
        optionsBuilder            
	        .UseNpgsql(connectionString)  
            .UseSnakeCaseNamingConvention();  
  
        return new MyDbContextFactory(optionsBuilder.Options);  
    }}
</code></pre>
<p>Service registration that gives us access to the factory:</p>
<pre><code class="language-csharp">builder.Services.AddSingleton&lt;IMyDbContextFactory, MyDbContextFactory&gt;();
</code></pre>
<p>To get the migrations rolling we still use <code>dotnet ef</code> tooling locally.</p>
<pre><code class="language-bash">dotnet ef migrations add MyMigration
</code></pre>
<p>With migrations enabled, which work fine locally using the <code>dotnet ef</code> tools, I found that this setup doesn't really work using the <code>dotnet_core_buildpack</code> on Cloud Foundry. After some searching and several attempts of using <code>dotnet ef</code> during the buildpack phases I gave up and went the custom route.</p>
<p>The code (that lives in <code>Program.cs</code>) below will take the startup code down a different branch when the <code>--migrate</code> argument is passed to the application. Because all the services and configuration are registered we can request our factory from the initialized service collection and grab an instance of our <code>DbContext</code> instance. Using this context we can apply all pending migrations using the <code>context.Database.Migrate()</code> method.</p>
<pre><code class="language-csharp">// Service and Configuration registration.

var app = builder.Build();

if (args.FirstOrDefault(string.Empty) == &quot;--migrate&quot;)  
{  
    var contextFactory = app.Services.GetService&lt;IMyDbContextFactory&gt;();
    if (contextFactory == null)  
    {
	    throw new Exception(&quot;ContextFactory could not be located!&quot;);    
    }
    
    Console.WriteLine(&quot;Applying database migrations...&quot;);  
    var context = contextFactory.Create();  
    context.Database.Migrate();  
    Console.WriteLine(&quot;Migrations applied successfully!&quot;);
    
    return;  
}

// More bootstrapping

app.Run();
</code></pre>
<p>During deployment on the platform we want to apply migrations when the app is deployed but not yet started. We can deploy our app with 0 instances and then run a task on the platform that applies the migrations by passing the <code>--migrate</code> argument.</p>
<pre><code class="language-shell">cf push -i 0
</code></pre>
<p>After deployment but before startup (there are no instances running yet), run a Cloud Foundry task against the app. The app assembly is the result of a <code>dotnet publish</code> command that we run in our CI system, so this solution assumes you are deploying built applications, not source.</p>
<p>If you should take the app completely offline is an interesting topic all on its own. Depending on your migrations and what you are trying to accomplish you might be able to get away without downtime but for the sake of safety, this example accepts a very brief period of downtime as the migrations are being applied to ensure that migrations are applied in a single task, and we don't risk multiple app instances all trying to apply the migrations at the same time as they are starting up.</p>
<pre><code class="language-shell">cf run-task my-app --command &quot;\&quot;./my-app-assembly --migrate\&quot;&quot; --name migrate-database --wait
</code></pre>
<p>When the task completes successfully and our database is in its desired state we can scale the app to the desired count.</p>
<pre><code class="language-shell">cf scale my-app -i 2
</code></pre>
<p>Local migrations can be applied using the same setup:</p>
<pre><code class="language-shell">dotnet run --project my-app-project.csproj -- --migrate
</code></pre>
<p>The <code>dotnet_core_buildpack</code> does not seem (I was unable to find anything related to additional <code>dotnet</code> tools) to be able to use tools like <code>dotnet ef</code>. Using the solution outlined in this post you can work around not having the tools and instead let the application apply the migrations.</p>
<p>You'll want to roll all this into some kind of CI/CD system because these manual steps are easy to mess up. See you in the next one!</p>

      </div>
    </main>
    <footer>
      <div class="content-wrapper">
        <p>Â© 2025 harre.dev</p>
       </div>
    </footer>
  </body>
</html>
