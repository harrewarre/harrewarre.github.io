<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASP.NET Core logging on Cloud Foundry</title>
    <link rel="stylesheet" href="/assets/style/theme.css">
  </head>
  <body>
    <header>
        <div class="content-wrapper">
            <h1><a href="/">harre.dev</a></h1>
        </div>
    </header>
    <nav>
        <div class="content-wrapper">
          <a href="/">home</a>
          <a href="/blog">blog</a>
          <a href="/about">about</a>
          <a href="feed.xml">rss</a>
        </div>
    </nav>
    <main>
      <div class="content-wrapper">
        <p>All apps I've ever worked on have some sort of logging going on for various reasons, mostly to keep track of whats going on or debugging, but it's all the same. Logs are needed to see what your code is up to.</p>
<p>Cloud Foundry <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/streaming-logs.html#writing">is very explicit</a> about <em>how</em> an app should write its logs. As you can see in the documentation, apps must write to <code>stdout</code> or <code>stderr</code>.</p>
<p>For C# that means we can use the static methods on the <code>Console</code> to write our logs. Couldn't be easier. But... now our code is littered with these <code>Console.Write...</code> lines all over the place!</p>
<p>Ok, easy, wrap it up in a simple class with an interface and inject it. That's a better solution for sure, but .NET provides an easy to use, injectable <code>ILogger</code> we can take advantage of. Let's see how we can set it up for console logging and use it in our apps we want to run on Cloud Foundry.</p>
<p>The <code>ILogger</code> mentioned earlier can be configured in the same way the configuration is handled. In the <code>Main</code> method, were the host is built, we can call the <code>.ConfigureLogging(...)</code> method and get access to logging bits.</p>
<p>public static void Main(string[] args)
{
CreateWebHostBuilder(args).Build().Run();
}</p>
<p>public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;
WebHost.CreateDefaultBuilder(args)
.ConfigureLogging((logging) =&gt; {
-- [access logging here! --
})
.UseStartup<Startup>();</p>
<p>Because we only want to log to the console, we start with removing any default (Console, Debug and EventSource) that might be present:</p>
<p>logging.ClearProviders();</p>
<p>And we add the console provider:</p>
<p>logging.AddConsole();</p>
<p>This setup will make the <code>ILogger</code> instance log only to the console. Using <code>ILogger</code> is just like using a regular service. It's already present in the services collection and can be injected without further configuration. Here's an example with the <code>ValuesController</code> from an untouched .NET Core WebAPI project:</p>
<p>[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
private readonly ILogger<ValuesController> _logger;</p>
<p>public ValuesController(ILogger<ValuesController> logger)
{
_logger = logger;
}</p>
<p>// GET api/values
[HttpGet]
public ActionResult&lt;IEnumerable<string>&gt; Get()
{
_logger.LogTrace(&quot;--- trace&quot;);
_logger.LogDebug(&quot;--- debug&quot;);
_logger.LogInformation(&quot;--- info&quot;);
_logger.LogWarning(&quot;--- warning&quot;);
_logger.LogError(&quot;--- error&quot;);
_logger.LogCritical(&quot;--- critical&quot;);</p>
<p>return new string[] { &quot;value1&quot;, &quot;value2&quot; };
}</p>
<p>...
}</p>
<p>Running this locally and calling the <code>/api/values</code> endpoint will show the following (and a whole lot more) output:</p>
<p>trce: app.Controllers.ValuesController[0]
--- trace
dbug: app.Controllers.ValuesController[0]
--- debug
info: app.Controllers.ValuesController[0]
--- info
warn: app.Controllers.ValuesController[0]
--- warning
fail: app.Controllers.ValuesController[0]
--- error
crit: app.Controllers.ValuesController[0]
--- critical</p>
<p>Keep in mind that to see ALL the output, you need to tell the logger to do so in <code>appsettings.*.json</code> by setting the desired log level! (You might want to keep it at Information, or even Warning)</p>
<p>{
&quot;Logging&quot;: {
&quot;LogLevel&quot;: {
&quot;Default&quot;: &quot;Trace&quot;
}
}
}</p>
<p>The built-in logger uses a type (in this case <code>ValuesController</code>) as the category as seen in the output. For more options and features you can check to full documentation to for logging in aspnet core <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-2.2">here</a>.</p>
<p>When you <code>cf push</code> this to Cloud Foundry and call the same endpoint you'll see something like this:</p>
<p>2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT trce: app.Controllers.ValuesController[0]
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT       --- trace
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT dbug: app.Controllers.ValuesController[0]
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT       --- debug
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT info: app.Controllers.ValuesController[0]
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT       --- info
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT warn: app.Controllers.ValuesController[0]
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT       --- warning
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT fail: app.Controllers.ValuesController[0]
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT       --- error
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT crit: app.Controllers.ValuesController[0]
2019-01-10T11:43:19.35+0100 [APP/PROC/WEB/0] OUT       --- critical</p>
<p>So now you are all set up with proper logging in ASP.NET Core (2.2) that complies with the requirements set by the Cloud Foundry platform.</p>

      </div>
    </main>
    <footer>
      <div class="content-wrapper">
        <p>Â© 2025 harre.dev</p>
       </div>
    </footer>
  </body>
</html>
